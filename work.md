### 工作安排

## 一、raft设计
### 1.1 raft项目设计
<p> 
    
</p>

## 二、具体的工作安排
### 2.1 Grpc测试
- [x] 完成grpc的服务端测试
    > 启动一个server，监听7061端口
- [x] 完成grpc客户端测试
    > 启动client，向本地7061端口发送投票请求 
    > 
    > sendVoteRequest

### 2.2 实验节点的倒计时机制
- [x] 完成节点的状态转换的实验

### 2.3 follow节点的循环实验
- [ ] 基本实验
    > 要求使用命令启动节点，加载好配置信息
    > 
    > go 启动grpc服务（接收到的消息以通道的方式传递给客户端）
    > 
    > go 启动主循环，不断的进行循环处理
    >
    > 完成以下状态转换
    >
    > follow超时成为Candidate
    >
    > Candidate求票
    > 
    > Candidate成为leader并向其他节点发送append请求

## 三、开发过程中遇到的问题
### 3.1 如何进行节点状态的转换？
    有一些全局的配置信息，
    比如获取当前节点的State信息（用mutex进行保护）
    这时候，如果要启动本节点。我们会启动一个循环loop，这个循环不断利用这个State进行判断当前的状态。
    若为 Follower  启动 followerLoop()
	若为 Candidate 启动 candidateLoop()
	若为 Leader    启动 leaderLoop()
    在每个相应的循环中也是根据State的信息来维持着不断的循环。


### 3.2 节点的倒计时是怎么来做的？
#### 3.2.1 使用线程来做这个事情
    当当前的状态改变为follow状态时
    需要安排一个线程每隔1s对leader的生命值-1
    ps： 当收到leader发来的append请求的时候，更新leader生命值为10
    当生命值降低为0时，利用通道发送一个leaderDead请求
    请求发送之后，当前的线程可以结束了
    
#### 3.2.2 使用通道来做这个事情
    即使用上述3.1循环的方式来处理系统中的事件。 
    在follow启动的时候就启动这么一个倒计时装置，
    当follow在这个倒计时的时间中收到消息的时候，我们就设置update=true
    当倒计时结束的时候，即收到了这个通道传过来的消息，
    我们就通过判断update的值判断是否需要重启倒计时还是成为候选者

### 3.3 什么时候需要互斥访问？
    用节点的State举例，
    State这个状态的使用方是循环的判断条件。
    State的更新方也是在循环中，那为什么要加入互斥访问，搞不懂。

### 3.4 默认配置的节点信息中包含本机的配置信息，该怎么处理？
    当本机是leader时，本机需要向本节点发送日志信息吗？ 不需要
    所以，在指定本机配置文件的时候移除一下本节点信息。

### 3.5 当raft系统中存在两个leader时（旧leader不认为自己是失效的），出现日志冲突这个怎么办？
    







